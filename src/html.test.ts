// tslint:disable:max-line-length
import {assert} from "chai";
import {Annotation} from "./annotation";
import {renderToString} from "./html";

describe("renderToString", () => {

  it("Writes simplified html strings when simpleHTML is passed", () => {
    const atns: Annotation[] = [
      {start: 1, end: 2, type: "redaction", content: "*"},
    ];
    assert.equal(renderToString("Foo\nBar", atns, {simpleHTML: true}),
`<p>F<span style="white-space: pre-wrap; word-break: break-word;">*</span>o</p><p>
Bar</p>`);
  });

  it("skips render if input is null or undefined", () => {
    assert.equal(renderToString(null, []), "");
    assert.equal(renderToString(undefined, []), "");
  });

  it("Returns text directly with no annotations", () => {
    assert.equal(renderToString("Foo", [], {autoParagraph: false}), "Foo");
  });

  it("Returns auto-generated paragraph breaks by default", () => {
    assert.equal(renderToString("Foo\nBar", []),
`<p data-sharpie-start="0" data-sharpie-end="3" data-sharpie-warp="1" data-sharpie-id="inferred-0" class="sharpie-annotation sharpie-type-markup auto-para-break">Foo</p><p data-sharpie-start="3" data-sharpie-end="7" data-sharpie-warp="1" data-sharpie-id="inferred-1" class="sharpie-annotation sharpie-type-markup auto-para-break">
Bar</p>`);
  });

  it("Returns custom markup annotations", () => {
    const atns: Annotation[] = [
      {start: 1, end: 5, type: "markup", format: {color: "blue"}},
    ];
    assert.equal(renderToString("Testing annotation", atns, {autoParagraph: false}),
`T<span data-sharpie-start="1" data-sharpie-end="5" data-sharpie-warp="1" data-sharpie-id="0" style="color: blue;" class="sharpie-annotation sharpie-type-markup">esti</span>ng annotation`);
  });

  it("Correctly closes and reopens overlapping markup annotations", () => {
    const atns: Annotation[] = [
      {start: 1, end: 5, type: "markup", format: {color: "blue"}},
      {start: 3, end: 9, type: "markup", format: {bgColor: "green"}},
    ];
    assert.equal(renderToString("Testing annotation", atns, {autoParagraph: false}),
`T<span data-sharpie-start="1" data-sharpie-end="5" data-sharpie-warp="1" data-sharpie-id="0" style="color: blue;" class="sharpie-annotation sharpie-type-markup">es<span data-sharpie-start="3" data-sharpie-end="5" data-sharpie-warp="1" data-sharpie-id="1" style="background-color: green;" class="sharpie-annotation sharpie-type-markup">ti</span></span><span data-sharpie-start="5" data-sharpie-end="9" data-sharpie-warp="1" data-sharpie-id="1" style="background-color: green;" class="sharpie-annotation sharpie-type-markup">ng a</span>nnotation`);
  });

  it("Handles complicated stacks of overlapping and autogenerated markup annotations", () => {
    const atns: Annotation[] = [
      {start: 1, end: 10, type: "markup", format: {color: "blue"}},
      {start: 5, end: 6, type: "markup", meta: {htmlTagName: "em"}},
      {start: 5, end: 15, type: "markup", format: {bgColor: "green"}},
      {start: 3, end: 25, type: "markup", format: {opacity: 0.5}},
      {start: 14, end: 25, type: "markup", meta: {htmlTagName: "strong", htmlClassName: "test"}},
    ];
    const str = `This test checks that

the renderer can handle
complicated

stacks of custom annotations and auto-generated

paragraph annotations.`;

    assert.equal(renderToString(str, atns),
`<p data-sharpie-start="0" data-sharpie-end="21" data-sharpie-warp="1" data-sharpie-id="inferred-0" class="sharpie-annotation sharpie-type-markup auto-para-break">T<span data-sharpie-start="1" data-sharpie-end="10" data-sharpie-warp="1" data-sharpie-id="0" style="color: blue;" class="sharpie-annotation sharpie-type-markup">hi<span data-sharpie-start="3" data-sharpie-end="10" data-sharpie-warp="1" data-sharpie-id="3" style="opacity: 0.5;" class="sharpie-annotation sharpie-type-markup">s <em data-sharpie-start="5" data-sharpie-end="6" data-sharpie-warp="1" data-sharpie-id="1" class="sharpie-annotation sharpie-type-markup"><span data-sharpie-start="5" data-sharpie-end="6" data-sharpie-warp="1" data-sharpie-id="2" style="background-color: green;" class="sharpie-annotation sharpie-type-markup">t</span></em><span data-sharpie-start="6" data-sharpie-end="10" data-sharpie-warp="1" data-sharpie-id="2" style="background-color: green;" class="sharpie-annotation sharpie-type-markup">est </span></span></span><span data-sharpie-start="10" data-sharpie-end="15" data-sharpie-warp="1" data-sharpie-id="2" style="background-color: green;" class="sharpie-annotation sharpie-type-markup"><span data-sharpie-start="10" data-sharpie-end="15" data-sharpie-warp="1" data-sharpie-id="3" style="opacity: 0.5;" class="sharpie-annotation sharpie-type-markup">chec<strong data-sharpie-start="14" data-sharpie-end="15" data-sharpie-warp="1" data-sharpie-id="4" class="sharpie-annotation sharpie-type-markup test">k</strong></span></span><strong data-sharpie-start="15" data-sharpie-end="21" data-sharpie-warp="1" data-sharpie-id="4" class="sharpie-annotation sharpie-type-markup test"><span data-sharpie-start="15" data-sharpie-end="21" data-sharpie-warp="1" data-sharpie-id="3" style="opacity: 0.5;" class="sharpie-annotation sharpie-type-markup">s that</span></strong></p><p data-sharpie-start="21" data-sharpie-end="22" data-sharpie-warp="1" data-sharpie-id="inferred-1" class="sharpie-annotation sharpie-type-markup auto-para-break"><span data-sharpie-start="21" data-sharpie-end="22" data-sharpie-warp="1" data-sharpie-id="3" style="opacity: 0.5;" class="sharpie-annotation sharpie-type-markup"><strong data-sharpie-start="21" data-sharpie-end="22" data-sharpie-warp="1" data-sharpie-id="4" class="sharpie-annotation sharpie-type-markup test">
</strong></span></p><p data-sharpie-start="22" data-sharpie-end="46" data-sharpie-warp="1" data-sharpie-id="inferred-2" class="sharpie-annotation sharpie-type-markup auto-para-break"><strong data-sharpie-start="22" data-sharpie-end="25" data-sharpie-warp="1" data-sharpie-id="4" class="sharpie-annotation sharpie-type-markup test"><span data-sharpie-start="22" data-sharpie-end="25" data-sharpie-warp="1" data-sharpie-id="3" style="opacity: 0.5;" class="sharpie-annotation sharpie-type-markup">
th</span></strong>e renderer can handle</p><p data-sharpie-start="46" data-sharpie-end="58" data-sharpie-warp="1" data-sharpie-id="inferred-3" class="sharpie-annotation sharpie-type-markup auto-para-break">
complicated</p><p data-sharpie-start="58" data-sharpie-end="59" data-sharpie-warp="1" data-sharpie-id="inferred-4" class="sharpie-annotation sharpie-type-markup auto-para-break">
</p><p data-sharpie-start="59" data-sharpie-end="107" data-sharpie-warp="1" data-sharpie-id="inferred-5" class="sharpie-annotation sharpie-type-markup auto-para-break">
stacks of custom annotations and auto-generated</p><p data-sharpie-start="107" data-sharpie-end="108" data-sharpie-warp="1" data-sharpie-id="inferred-6" class="sharpie-annotation sharpie-type-markup auto-para-break">
</p><p data-sharpie-start="108" data-sharpie-end="131" data-sharpie-warp="1" data-sharpie-id="inferred-7" class="sharpie-annotation sharpie-type-markup auto-para-break">
paragraph annotations.</p>`);
  });

  it("Handles directly overlapping ranges without reopening tags, with correct block tag sorting", () => {
    const atns: Annotation[] = [
      {start: 0, end: 6, type: "markup", meta: {htmlTagName: "h1"}},
      {start: 0, end: 6, type: "highlight"},
    ];
    const str = `Header

Some other text`;
    assert.equal(renderToString(str, atns),
`<p data-sharpie-start="0" data-sharpie-end="6" data-sharpie-warp="1" data-sharpie-id="inferred-0" class="sharpie-annotation sharpie-type-markup auto-para-break"><h1 data-sharpie-start="0" data-sharpie-end="6" data-sharpie-warp="1" data-sharpie-id="0" class="sharpie-annotation sharpie-type-markup"><span data-sharpie-start="0" data-sharpie-end="6" data-sharpie-warp="1" data-sharpie-id="1" class="sharpie-annotation sharpie-type-highlight">Header</span></h1></p><p data-sharpie-start="6" data-sharpie-end="7" data-sharpie-warp="1" data-sharpie-id="inferred-1" class="sharpie-annotation sharpie-type-markup auto-para-break">
</p><p data-sharpie-start="7" data-sharpie-end="23" data-sharpie-warp="1" data-sharpie-id="inferred-2" class="sharpie-annotation sharpie-type-markup auto-para-break">
Some other text</p>`);
  });

  it("Forces reopenings for inline tags trying to contain block tags", () => {
    const atns: Annotation[] = [
      {start: 0, end: 10, type: "markup", meta: {htmlTagName: "span"}},
      {start: 4, end: 6, type: "markup", meta: {htmlTagName: "h1"}},
    ];
    const str = `0123456789`;
    assert.equal(renderToString(str, atns, {autoParagraph: false}),
`<span data-sharpie-start="0" data-sharpie-end="4" data-sharpie-warp="1" data-sharpie-id="0" class="sharpie-annotation sharpie-type-markup">0123</span><h1 data-sharpie-start="4" data-sharpie-end="6" data-sharpie-warp="1" data-sharpie-id="1" class="sharpie-annotation sharpie-type-markup"><span data-sharpie-start="4" data-sharpie-end="6" data-sharpie-warp="1" data-sharpie-id="0" class="sharpie-annotation sharpie-type-markup">45</span></h1><span data-sharpie-start="6" data-sharpie-end="10" data-sharpie-warp="1" data-sharpie-id="0" class="sharpie-annotation sharpie-type-markup">6789</span>`);
  });

  it("Forces reopenings for highlights trying to contain redactions", () => {
    const atns: Annotation[] = [
      {start: 0, end: 10, type: "highlight"},
      {start: 4, end: 6, type: "redaction"},
    ];
    const str = `0123456789`;
    assert.equal(renderToString(str, atns, {autoParagraph: false}),
`<span data-sharpie-start="0" data-sharpie-end="4" data-sharpie-warp="1" data-sharpie-id="0" class="sharpie-annotation sharpie-type-highlight">0123</span><span data-sharpie-start="4" data-sharpie-end="6" data-sharpie-warp="1" data-sharpie-id="1" style="white-space: pre-wrap; word-break: break-word;" class="sharpie-annotation sharpie-type-redaction"><span data-sharpie-start="4" data-sharpie-end="6" data-sharpie-warp="1" data-sharpie-id="0" class="sharpie-annotation sharpie-type-highlight">&nbsp;&nbsp;</span></span><span data-sharpie-start="6" data-sharpie-end="10" data-sharpie-warp="1" data-sharpie-id="0" class="sharpie-annotation sharpie-type-highlight">6789</span>`);
  });

  it("Ignores annotations with invalid ranges", () => {
    assert.equal(renderToString("foo", [{start: 2, end: 1, type: "highlight"}], {autoParagraph: false}), "foo");
  });

  it("Allocates IDs in the input order, not render order", () => {
    const atns: Annotation[] = [
      {start: 0, end: 5, type: "markup", meta: {htmlTagName: "span"}},
      {start: 0, end: 5, type: "markup", meta: {htmlTagName: "h1"}},
    ];
    const str = `01234`;
    assert.equal(renderToString(str, atns, {autoParagraph: false}),
`<h1 data-sharpie-start="0" data-sharpie-end="5" data-sharpie-warp="1" data-sharpie-id="1" class="sharpie-annotation sharpie-type-markup"><span data-sharpie-start="0" data-sharpie-end="5" data-sharpie-warp="1" data-sharpie-id="0" class="sharpie-annotation sharpie-type-markup">01234</span></h1>`);
  });

});
